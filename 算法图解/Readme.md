# 算法图解

## 内容Map

- [x] 二分算法
- [x] 数组与链表

## 笔记整理

### 二分算法

二分查找是一种算法，其输入是一个有序的元素列表。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回`null`。

对于一个有`n`个元素的有序数组，简单查找最多需要`n`步，而二分查找最多需要`log2n`向下取整再`+1`步。如果要查找的元素存在于有序数组中，且不为结尾的边界元素，则最多只需要`log2n`步；如果要查找的元素不存在于有序数组中，或是有序数组结尾的元素，则最多需要`log2n`向下取整再`+1`步。

简单查找的运行时间为线性时间，时间复杂度为`O(n)`，二分查找的运行时间为对数时间（或`log`时间），时间复杂度为`O(logn)`。

### 大O表示法

大O表示法除了用于预估一个算法需要多长时间才能运行完毕，还能够用于预估运行时间如何随列表增长而增加。大O表示法，O后边的括号中是操作数。

一些很常见的大O运行时间有：`O(logn)`、`O(n)`、`O(n*logn)`、`O(n2)`、`O(n!)`。

算法的速度指的并非时间，而是操作数的增速。谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加，即是从其增速的角度度量。

算法的运行时间用大O表示法表示，大O表示法指出的是最糟糕的情况。

### 旅行商问题

一位旅行商要前往`n`个城市，现要考虑前往这`n`个城市的各种顺序（正向顺序和逆向顺序算两次），需要执行`n!`次操作才能计算出结果，因此此算法的时间复杂度为`O(n!)`。这是计算机科学领域待解的问题之一。对于这个问题，目前还没有找到更快的算法，有些很聪明的人认为这个问题根本就没有更巧妙的算法。面对这个问题，我们能做的只是去找出近似答案。

旅行商问题实际上是排列组合中的排列问题。排列组合是组合学最基本的概念。所谓排列，就是指从给定个数的元素中取出指定个数的元素进行排序。组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。

#### 排列

排列的定义：从`n`个不同元素中，任取`m`(`m≤n`,`m`与`n`均为自然数,下同）个不同的元素按照一定的顺序排成一列，叫做从`n`个不同元素中取出m个元素的一个排列；从`n`个不同元素中取出`m`（`m≤n`）个元素的所有排列的个数，叫做从`n`个不同元素中取出`m`个元素的排列数，用符号`A(n,m)`表示。

计算公式：

![排列计算公式](http://4picture.test.upcdn.net/superbed/2019/11/07/5dc3ca678e0e2e3ee9582676.jpg)

此外，**规定`0! = 1`**。

因此，旅行商问题即为从`n`个元素中取`n`个元素进行排列的问题，按上述公式，即`n=m`，因此可推导得出`A(n,n) = n! / 0! = n! / 1 = n!`。

#### 组合

组合的定义：从`n`个不同元素中，任取`m`（`m≤n`）个元素并成一组，叫做从`n`个不同元素中取出`m`个元素的一个组合；从`n`个不同元素中取出`m`（`m≤n`）个元素的所有组合的个数，叫做从`n`个不同元素中取出`m`个元素的组合数。用符号`C(n,m)`表示。

计算公式：

![组合计算公式](http://4picture.test.upcdn.net/superbed/2019/11/07/5dc3ccae8e0e2e3ee95853c8.jpg)

### 数组与链表

数组的读取复杂度为`O(1)`（常量时间），插入、删除复杂度为`O(n)`（线性时间）；链表的读取复杂度为`O(n)`（线性时间），插入、删除复杂度为`O(1)`（常量时间）。

向数组添加元素，如果发现连续可用内存不足，会在内存中将数组整体迁移，因此数组新增元素的速度会很慢。如果是静态语言，可以选择为数组预留长度的方式，但这种方式的两个弊端是：`预留的空间如果没有使用是种浪费`、`如果预留的空间不足，还是要整体迁移`。动态语言速度上慢于静态语言的一点原因是，诸如数组等数据类型，动态语言并没有要求必须确认长度，而在计算机内部，内存的分配是一定的，因此动态语言中这部分工作都交给了解释器执行，这一步是需要消耗时间的。

数组的下标从零开始有一种思路：将这个下标看作相对于数组第一个元素的偏移量。则第一个元素相对于自身偏移量为`0`，第二个为`1`，依次类推。

### 数组链表

来自Facebook用户名存储案例，具体如下：

  实际上，Facebook存储用户信息时使用的既不是数组也不是链表。假设Facebook使用的是一种混合数据：链表数组。这个数组包含26个元素，每个元素都指向一个链表。例如，该数组的第一个元素指向的链表包含所有以A打头的用户名，第二个元素指向的链表包含所有以B打头的用户名，以此类推。

数组链表综合了数组和链表的优点：

1. 因为数组长度固定，不用担心会发生数组迁移
2. 因为数组内容有序，可以使用二分法查找首字母
3. 因为某一首字母下的用户名使用链表存储，插入和删除比数组快得多

数组链表与数组相比：查找比数组慢（因为还要查链表），但插入比数组快（因为无需元素迁移）；数组链表与链表相比：查找比链表快（因为可以借助数组缩小查询范围，并且查询数组时可以使用二分算法），如果不考虑插入前的查找工作，则插入同链表速度差不多（因为都是链表的插入）、如果考虑插入前的查找工作，则插入比链表快（因为需要被查询的链表元素少了）。

### 排序算法

#### 选择排序

现有无序数组A，要对A进行从大到小的排序。选择排序方法是先新建一个数组B，然后开始进行排序：遍历A，找到A中此时最大的值，将此值推入B，并在A中剔除，然后再次上述操作，直到所有的元素都被处理完毕。

选择排序是一种灵巧的算法（虽然我没看出来哪里灵巧），但它速度较慢。对于A中的每一个元素都要遍历一遍整个数组（平均每次要遍历`n/2`个元素），A中共有`n`个元素，因此要执行`n`此遍历，则其时间复杂度为`O(n2)`（其实应该是`O(n2/2)`，但类似二分之一之类的常数在大O表示法中会被忽略不计）。